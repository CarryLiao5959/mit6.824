# 4 优化

虽然仅通过编写Map和Reduce函数就能提供的基本功能足以满足大部分需求，但我们发现几个扩展非常有用。本节将描述这些扩展。

## 4.1 分区函数

MapReduce的用户指定他们期望的reduce任务/输出文件的数量(R)。数据通过在中间键上使用分区函数跨这些任务进行分区。默认提供一个使用散列（例如“hash(key) mod R”）的分区函数。这往往会导致分区相当平衡。然而，在某些情况下，按照键的某个其他函数进行数据分区可能是有用的。例如，有时输出键是URL，我们希望同一主机的所有条目都在同一输出文件中结束。为了支持这样的情况，MapReduce库的用户可以提供一个特殊的分区函数。例如，使用“hash(Hostname(urlkey)) mod R”作为分区函数会使来自同一主机的所有URL都在同一输出文件中结束。

## 4.2 排序保证

我们保证在给定的分区内，中间键/值对按照键的递增顺序处理。这个排序保证使得每个分区都能轻易生成一个排序的输出文件，这在输出文件格式需要支持按键有效的随机访问查找，或者输出的用户发现有序数据方便时，非常有用。

## 4.3 组合器函数

在某些情况下，每个map任务产生的中间键中存在大量重复，而用户指定的Reduce函数是可交换和关联的。第2.1节中的单词计数示例就是一个很好的例子。由于单词频率往往遵循Zipf分布，每个map任务将产生数百或数千条形如<the, 1>的记录。所有这些计数将通过网络发送到一个单一的reduce任务，然后由Reduce函数将它们加在一起生成一个数字。我们允许用户指定一个可选的Combiner函数，该函数在数据通过网络发送之前，对数据进行部分合并。

Combiner函数在执行map任务的每台机器上执行。通常，相同的代码用于实现combiner函数和reduce函数。reduce函数和combiner函数之间的唯一区别是MapReduce库如何处理函数的输出。reduce函数的输出写入最终的输出文件。combiner函数的输出写入一个将被发送到reduce任务的中间文件。

部分组合显著加速了某些类别的MapReduce操作。附录A包含了一个使用combiner的示例。

## 4.4 输入和输出类型

MapReduce库支持以几种不同的格式读取输入数据。例如，“文本”模式的输入将每行视为一个键/值对：键是文件中的偏移量，值是行的内容。另一个常见的支持格式存储了按键排序的键/值对序列。每种输入类型的实现都知道如何将自身分割为可作为单独的map任务处理的有意义的范围（例如，文本模式的范围分割确保范围分割仅发生在行边界）。用户可以通过提供一个简单的读取器接口的实现来添加对新输入类型的支持，尽管大多数用户只使用预定义输入类型中的少数几种。

一个读取器并不必须提供从文件读取的数据。例如，定义一个从数据库或映射在内存中的数据结构读取记录的读取器是很容易的。

同样，我们支持一套输出类型，用于以不同格式产生数据，并且用户代码可以轻易地添加对新输出类型的支持。

## 4.5 副作用

在某些情况下，MapReduce的用户发现产生辅助文件作为他们的map和/或reduce操作符的附加输出很方便。我们依赖于应用程序编写者使这种副作用具有原子性和幂等性。通常，应用程序写入临时文件，一旦文件生成完毕，就对该文件进行原子重命名。

我们不提供支持一个任务产生的多个输出文件的原子两阶段提交。因此，应该确定产生具有跨文件一致性要求的多个输出文件的任务。在实践中，这个限制从未成为问题。

## 4.6 跳过错误记录

有时，用户代码中的bug会导致Map或Reduce函数在某些记录上确定性地崩溃。这样的bug阻止了MapReduce操作的完成。通常的做法是修复bug，但有时这是不可行的；也许bug在第三方库中，无法获得源代码。此外，有时忽略几条记录是可以接受的，例如在对大型数据集进行统计分析时。我们提供了一个可选的执行模式，其中MapReduce库检测哪些记录导致确定性崩溃，并跳过这些记录以进行前进。

每个工作进程都安装一个信号处理器，用于捕获段错误和总线错误。在调用用户的Map或Reduce操作之前，MapReduce库将参数的序列号存储在全局变量中。如果用户代码产生了一个信号，信号处理器会发送一个“最后的呼吸”UDP包，该包包含序列号到MapReduce主节点。当主节点看到一个特定记录上有超过一次失败时，它会在发出下一个对应的Map或Reduce任务的重执行时指示该记录应被跳过。

## 4.7 本地执行

在Map或Reduce函数中调试问题可能会很棘手，因为实际的计算发生在一个分布式系统中，通常在数千台机器上，工作分配决策由master动态进行。为了帮助调试、性能分析和小规模测试，我们开发了MapReduce库的另一个实现，该实现将所有的MapReduce操作工作顺序地在本地机器上执行。用户被提供控制，以便将计算限制在特定的map任务上。用户带着一个特殊的标记调用他们的程序，然后可以轻松地使用他们觉得有用的任何调试或测试工具（例如，gdb）。

## 4.8 状态信息
Master运行一个内部的HTTP服务器，并提供一套供人类使用的状态页面。状态页面显示计算的进度，例如完成了多少任务，有多少正在进行，输入字节，中间数据字节，输出字节，处理速率等。页面也包含指向每个任务生成的标准错误和标准输出文件的链接。用户可以使用这些数据来预测计算将花费多长时间，以及是否应该为计算添加更多资源。这些页面也可用于确定计算何时比预期慢得多。

此外，顶级状态页面显示了哪些工人失败了，以及在失败时他们正在处理哪些map和reduce任务。当试图诊断用户代码中的错误时，此信息非常有用。

## 4.9 计数器
MapReduce库提供了一个计数器功能，用于统计各种事件的发生次数。例如，用户代码可能想要计算处理的单词总数或索引的德语文档数量等。

要使用此功能，用户代码创建一个命名的计数器对象，然后在Map和/或Reduce函数中适当地增加计数器。例如：

```go
Counter* uppercase;
uppercase = GetCounter("uppercase");
map(String name, String contents):
    for each word w in contents:
        if (IsCapitalized(w)):
            uppercase->Increment();
        EmitIntermediate(w, "1");
```

来自个别工作机的计数器值定期传播到master（搭载在ping响应上）。Master聚合来自成功的map和reduce任务的计数器值，并在MapReduce操作完成时返回给用户代码。当前的计数器值也显示在master的状态页面上，以便人类可以观察实时计算的进度。在聚合计数器值时，master消除了执行相同的map或reduce任务的副本的影响，以避免重复计数。（重复执行可能来自我们使用的备份任务和由于故障而重新执行的任务。）

一些计数器值由MapReduce库自动维护，如处理的输入键/值对的数量和产生的输出键/值对的数量。

用户发现计数器功能对于对MapReduce操作的行为进行完整性检查非常有用。例如，在一些MapReduce操作中，用户代码可能希望确保产生的输出对的数量恰好等于处理的输入对的数量，或者处理的德语文档的比例在处理的文档总数的可容忍比例内。