# 提示：

1. 开发和调试的提示请参见指导页面。

2. 开始的一个方法是修改mr/worker.go的Worker()，向协调者发送一个**RPC请求**，请求一个任务。然后修改协调者`coordinator`以回应一个尚未开始的map任务的文件名。然后修改worker以读取该文件，并调用应用的Map函数，如在mrsequential.go中所示。

   > RPC（Remote Procedure Call，远程过程调用）
   > 
   > 一种在网络上的不同系统之间进行通信的协议。在一种系统（客户端）上调用另一种系统（服务器）上的程序或函数，就像它们是在本地系统上的一样。这种方式使得开发者可以创建跨网络，跨系统的复杂应用，而不需要关注网络通信的细节。
   >
   > RPC请求是从客户端到服务器的调用请求。客户端发起请求，指定服务器上的过程以及所需的参数。   服务器接收到请求，执行过程，并返回结果到客户端。
   >
   > 这种模式被广泛应用在各种分布式系统和网络服务中，包括web服务，数据库应用等。

3. 应用程序的Map和Reduce函数在运行时使用Go的插件包从以.so结尾的文件中加载。

4. 如果你在mr/目录中更改了任何内容，你可能需要使用像`go build -buildmode=plugin ../mrapps/wc.go`这样的命令重新构建你使用的任何MapReduce插件。

5. 这个实验依赖于worker共享一个文件系统。当所有的worker都在同一台机器上运行时，这很简单，但如果worker在不同的机器上运行，就需要像GFS这样的全局文件系统。

   > GFS（Google文件系统）
   >
   >由Google公司开发的一个分布式文件系统，专门设计用于运行在廉价的   商用计算机硬件上。GFS的主要目标是提供强大的数据处理能力，以处理Google搜索引擎等大规模应用   程序产生的大量数据。
   >
   > GFS有一些显著的特性：
   >
   > 1. **容错性**：GFS设计成可以在经常出现硬件故障的环境中工作。它自动检测、忍受和从单个和   多个系统故障中恢复。
   >
   > 2. **高吞吐量**：GFS优化了持续的高数据吞吐量，甚至超过了低延迟单个文件读写的优先级。
   >
   > 3. **大文件**：GFS被设计用来存储和处理非常大的文件，可能是GB甚至TB级别的大小。这对许多   传统的文件系统来说是一个挑战。
   > 
   > 4. **一致性模型**：GFS有一个定义明确的一致性模型，它允许应用程序知道在系统故障时可以期   望什么。
   >
   > GFS有一个主服务器和多个分区服务器，主服务器负责元数据管理，分区服务器负责数据存储。这种   架构允许GFS在很多机器上分布存储和处理大量的数据。
   >
   > 请注意，虽然GFS对Google内部的许多服务很有价值，但它并不适合所有类型的应用程序或环境。Hadoop分布式文件系统（HDFS）是一个开源的、与GFS类似的文件系统，设计用于大规模数据处理。

6. 中间文件的合理命名约定是mr-X-Y，其中X是Map任务编号，Y是reduce任务编号。

7. worker的map任务代码需要一种方法，将中间键/值对存储在文件中，以便在reduce任务中正确地读回。一种可能是使用Go的`encoding/json`包。以JSON格式写入键/值对到一个打开的文件：

   ```go
   enc := json.NewEncoder(file)
   for _, kv := ... {
     err := enc.Encode(&kv)
   }
   ```

   并读取这样的文件：

   ```go
   dec := json.NewDecoder(file)
   for {
     var kv KeyValue
     if err := dec.Decode(&kv); err != nil {
       break
     }
     kva = append(kva, kv)
   }
   ```

8. 你的worker的map部分可以使用worker.go中的ihash(key)函数为给定的键选择reduce任务。

9. 你可以从mrsequential.go中抄一些代码来读取Map输入文件，对Map和Reduce之间的中间键/值对进行排序，并将Reduce输出存储在文件中。

10. 作为RPC服务器的协调者将是并发的；不要忘记锁定共享数据。

11. 使用Go的race detector，通过`go run -race`。`test-mr.sh`在开头有一条注释，告诉你如何使用-race来运行它。当我们对你的实验进行评分时，我们不会使用race detector。然而，如果你的代码有竞态，即使没有竞态检测器，我们在测试时也很可能会失败。

12. worker有时需要等待，例如，reduce不能开始，直到最后一个map完成。一种可能性是worker定期向协调者请求工作，在每次请求之间使用time.Sleep()休眠。另一种可能性是协调者中的相关RPC处理器有一个循环等待，无论是使用time.Sleep()还是sync.Cond。Go在每个RPC的自己的线程中运行处理器，所以一个处理器正在等待并不会阻止协调者处理其他RPC。

13. 协调者不能可靠地区分崩溃的worker、因某种原因停滞翻译，但仍然活着的worker，以及执行速度太慢以至于无法使用的worker。你能做的最好的就是让协调者等待一段时间，然后放弃并将任务重新发给另一个worker。对于这个实验，让协调者等待十秒；之后协调者应该假设worker已经死亡（当然，可能没有）。

14. 如果你选择实现备份任务（第3.6节），注意我们测试你的代码在worker执行任务时没有崩溃时，不会安排多余的任务。备份任务应该只在一段相对较长的时间（例如，10秒）后被安排。

15. 为了测试崩溃恢复，你可以使用mrapps/crash.go应用插件。它在Map和Reduce函数中随机退出。

16. 为了确保在出现崩溃的情况下，没有人能观察到部分写入的文件，MapReduce论文提到了使用临时文件和在完全写入后原子地重命名它的技巧。你可以使用ioutil.TempFile来创建一个临时文件和os.Rename来原子地重命名它。

17. test-mr.sh在mr-tmp子目录中运行所有的进程，所以如果出现了问题，你想查看中间文件或输出文件，请在那里查看。随意临时修改test-mr.sh在失败测试后退出，这样脚本就不会继续测试（并覆盖输出文件）。

18. test-mr-many.sh多次运行test-mr.sh，你可能想这样做，以便发现低概率的错误。它接受一个参数，表示运行测试的次数。你不应该并行运行多个test-mr.sh实例，因为协调者会重用相同的套接字，导致冲突。

19. Go RPC只发送字段名以大写字母开头的结构字段。子结构也必须有大写的字段名。

20. 当调用RPC call()函数时，回复结构应包含所有默认值。RPC调用应如下所示：

    ```go
    reply := SomeType{}
    call(..., &reply)
    ```

    在调用之前不要设置reply的任何字段。如果你传递了含有非默认字段的reply结构，RPC系统可能会静默地返回不正确的值。